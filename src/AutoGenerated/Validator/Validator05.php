<?php

declare(strict_types=1);

namespace Infection\BenchmarkSource\AutoGenerated\Validator;

use function array_key_exists;
use function count;
use function filter_var;
use function in_array;
use function is_array;
use function is_bool;
use function is_float;
use function is_int;
use function is_numeric;
use function is_string;
use function mb_strlen;
use function preg_match;
use function sprintf;
use function str_contains;

final class Validator05
{
    /**
     * @var list<string>
     */
    private array $errors = [];

    /**
     * @return list<string>
     */
    public function getErrors(): array
    {
        return $this->errors;
    }

    public function hasErrors(): bool
    {
        return count($this->errors) > 0;
    }

    public function clearErrors(): void
    {
        $this->errors = [];
    }

    private function addError(string $field, string $message): void
    {
        $this->errors[] = sprintf('%s: %s', $field, $message);
    }

    public function validateRequired(string $field, mixed $value): bool
    {
        if ($value === null || $value === '' || $value === []) {
            $this->addError($field, 'This field is required.');

            return false;
        }

        return true;
    }

    public function validateString(string $field, mixed $value): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'This field must be a string.');

            return false;
        }

        return true;
    }

    public function validateInteger(string $field, mixed $value): bool
    {
        if (!is_int($value)) {
            $this->addError($field, 'This field must be an integer.');

            return false;
        }

        return true;
    }

    public function validateFloat(string $field, mixed $value): bool
    {
        if (!is_float($value)) {
            $this->addError($field, 'This field must be a float.');

            return false;
        }

        return true;
    }

    public function validateNumeric(string $field, mixed $value): bool
    {
        if (!is_numeric($value)) {
            $this->addError($field, 'This field must be numeric.');

            return false;
        }

        return true;
    }

    public function validateBoolean(string $field, mixed $value): bool
    {
        if (!is_bool($value)) {
            $this->addError($field, 'This field must be a boolean.');

            return false;
        }

        return true;
    }

    public function validateArray(string $field, mixed $value): bool
    {
        if (!is_array($value)) {
            $this->addError($field, 'This field must be an array.');

            return false;
        }

        return true;
    }

    public function validateEmail(string $field, mixed $value): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'Email must be a string.');

            return false;
        }

        if (filter_var($value, FILTER_VALIDATE_EMAIL) === false) {
            $this->addError($field, 'Invalid email address.');

            return false;
        }

        return true;
    }

    public function validateUrl(string $field, mixed $value): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'URL must be a string.');

            return false;
        }

        if (filter_var($value, FILTER_VALIDATE_URL) === false) {
            $this->addError($field, 'Invalid URL.');

            return false;
        }

        return true;
    }

    public function validateMinLength(string $field, mixed $value, int $min): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'Value must be a string.');

            return false;
        }

        $length = mb_strlen($value);

        if ($length < $min) {
            $this->addError(
                $field,
                sprintf('Must be at least %d characters long, got %d.', $min, $length),
            );

            return false;
        }

        return true;
    }

    public function validateMaxLength(string $field, mixed $value, int $max): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'Value must be a string.');

            return false;
        }

        $length = mb_strlen($value);

        if ($length > $max) {
            $this->addError(
                $field,
                sprintf('Must be at most %d characters long, got %d.', $max, $length),
            );

            return false;
        }

        return true;
    }

    public function validateLength(string $field, mixed $value, int $min, int $max): bool
    {
        return $this->validateMinLength($field, $value, $min)
            && $this->validateMaxLength($field, $value, $max);
    }

    public function validateMin(string $field, mixed $value, int|float $min): bool
    {
        if (!is_numeric($value)) {
            $this->addError($field, 'Value must be numeric.');

            return false;
        }

        if ($value < $min) {
            $this->addError(
                $field,
                sprintf('Must be at least %s, got %s.', $min, $value),
            );

            return false;
        }

        return true;
    }

    public function validateMax(string $field, mixed $value, int|float $max): bool
    {
        if (!is_numeric($value)) {
            $this->addError($field, 'Value must be numeric.');

            return false;
        }

        if ($value > $max) {
            $this->addError(
                $field,
                sprintf('Must be at most %s, got %s.', $max, $value),
            );

            return false;
        }

        return true;
    }

    public function validateRange(string $field, mixed $value, int|float $min, int|float $max): bool
    {
        return $this->validateMin($field, $value, $min)
            && $this->validateMax($field, $value, $max);
    }

    public function validatePattern(string $field, mixed $value, string $pattern): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'Value must be a string.');

            return false;
        }

        if (preg_match($pattern, $value) !== 1) {
            $this->addError($field, 'Does not match the required pattern.');

            return false;
        }

        return true;
    }

    public function validateAlpha(string $field, mixed $value): bool
    {
        return $this->validatePattern($field, $value, '/^[a-zA-Z]+$/');
    }

    public function validateAlphanumeric(string $field, mixed $value): bool
    {
        return $this->validatePattern($field, $value, '/^[a-zA-Z0-9]+$/');
    }

    public function validateAlphaDash(string $field, mixed $value): bool
    {
        return $this->validatePattern($field, $value, '/^[a-zA-Z0-9_-]+$/');
    }

    /**
     * @param list<mixed> $allowedValues
     */
    public function validateIn(string $field, mixed $value, array $allowedValues): bool
    {
        if (!in_array($value, $allowedValues, true)) {
            $this->addError($field, 'Invalid value.');

            return false;
        }

        return true;
    }

    /**
     * @param list<mixed> $disallowedValues
     */
    public function validateNotIn(string $field, mixed $value, array $disallowedValues): bool
    {
        if (in_array($value, $disallowedValues, true)) {
            $this->addError($field, 'This value is not allowed.');

            return false;
        }

        return true;
    }

    public function validateEquals(string $field, mixed $value, mixed $expected): bool
    {
        if ($value !== $expected) {
            $this->addError($field, 'Value does not match expected value.');

            return false;
        }

        return true;
    }

    public function validateNotEquals(string $field, mixed $value, mixed $notExpected): bool
    {
        if ($value === $notExpected) {
            $this->addError($field, 'Value must not equal the given value.');

            return false;
        }

        return true;
    }

    public function validateContains(string $field, mixed $value, string $needle): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'Value must be a string.');

            return false;
        }

        if (!str_contains($value, $needle)) {
            $this->addError($field, 'Value does not contain the required substring.');

            return false;
        }

        return true;
    }

    public function validateStartsWith(string $field, mixed $value, string $prefix): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'Value must be a string.');

            return false;
        }

        if (!str_starts_with($value, $prefix)) {
            $this->addError($field, 'Value does not start with the required prefix.');

            return false;
        }

        return true;
    }

    public function validateEndsWith(string $field, mixed $value, string $suffix): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'Value must be a string.');

            return false;
        }

        if (!str_ends_with($value, $suffix)) {
            $this->addError($field, 'Value does not end with the required suffix.');

            return false;
        }

        return true;
    }

    public function validateArrayMinCount(string $field, mixed $value, int $min): bool
    {
        if (!is_array($value)) {
            $this->addError($field, 'Value must be an array.');

            return false;
        }

        $count = count($value);

        if ($count < $min) {
            $this->addError(
                $field,
                sprintf('Array must have at least %d items, got %d.', $min, $count),
            );

            return false;
        }

        return true;
    }

    public function validateArrayMaxCount(string $field, mixed $value, int $max): bool
    {
        if (!is_array($value)) {
            $this->addError($field, 'Value must be an array.');

            return false;
        }

        $count = count($value);

        if ($count > $max) {
            $this->addError(
                $field,
                sprintf('Array must have at most %d items, got %d.', $max, $count),
            );

            return false;
        }

        return true;
    }

    public function validateArrayCount(string $field, mixed $value, int $min, int $max): bool
    {
        return $this->validateArrayMinCount($field, $value, $min)
            && $this->validateArrayMaxCount($field, $value, $max);
    }

    /**
     * @param list<string> $requiredKeys
     */
    public function validateArrayHasKeys(string $field, mixed $value, array $requiredKeys): bool
    {
        if (!is_array($value)) {
            $this->addError($field, 'Value must be an array.');

            return false;
        }

        $valid = true;

        foreach ($requiredKeys as $key) {
            if (!array_key_exists($key, $value)) {
                $this->addError($field, sprintf('Missing required key: %s', $key));
                $valid = false;
            }
        }

        return $valid;
    }

    public function validateDate(string $field, mixed $value, string $format = 'Y-m-d'): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'Date must be a string.');

            return false;
        }

        $date = \DateTime::createFromFormat($format, $value);

        if ($date === false || $date->format($format) !== $value) {
            $this->addError($field, sprintf('Invalid date format, expected %s.', $format));

            return false;
        }

        return true;
    }

    public function validateDateBefore(string $field, mixed $value, string $before): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'Date must be a string.');

            return false;
        }

        $date = \DateTime::createFromFormat('Y-m-d', $value);
        $beforeDate = \DateTime::createFromFormat('Y-m-d', $before);

        if ($date === false || $beforeDate === false) {
            $this->addError($field, 'Invalid date format.');

            return false;
        }

        if ($date >= $beforeDate) {
            $this->addError($field, sprintf('Date must be before %s.', $before));

            return false;
        }

        return true;
    }

    public function validateDateAfter(string $field, mixed $value, string $after): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'Date must be a string.');

            return false;
        }

        $date = \DateTime::createFromFormat('Y-m-d', $value);
        $afterDate = \DateTime::createFromFormat('Y-m-d', $after);

        if ($date === false || $afterDate === false) {
            $this->addError($field, 'Invalid date format.');

            return false;
        }

        if ($date <= $afterDate) {
            $this->addError($field, sprintf('Date must be after %s.', $after));

            return false;
        }

        return true;
    }

    public function validateIpAddress(string $field, mixed $value): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'IP address must be a string.');

            return false;
        }

        if (filter_var($value, FILTER_VALIDATE_IP) === false) {
            $this->addError($field, 'Invalid IP address.');

            return false;
        }

        return true;
    }

    public function validateIpv4(string $field, mixed $value): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'IP address must be a string.');

            return false;
        }

        if (filter_var($value, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4) === false) {
            $this->addError($field, 'Invalid IPv4 address.');

            return false;
        }

        return true;
    }

    public function validateIpv6(string $field, mixed $value): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'IP address must be a string.');

            return false;
        }

        if (filter_var($value, FILTER_VALIDATE_IP, FILTER_FLAG_IPV6) === false) {
            $this->addError($field, 'Invalid IPv6 address.');

            return false;
        }

        return true;
    }

    public function validateJson(string $field, mixed $value): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'JSON must be a string.');

            return false;
        }

        json_decode($value);

        if (json_last_error() !== JSON_ERROR_NONE) {
            $this->addError($field, 'Invalid JSON.');

            return false;
        }

        return true;
    }

    public function validateUuid(string $field, mixed $value): bool
    {
        if (!is_string($value)) {
            $this->addError($field, 'UUID must be a string.');

            return false;
        }

        $pattern = '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i';

        if (preg_match($pattern, $value) !== 1) {
            $this->addError($field, 'Invalid UUID format.');

            return false;
        }

        return true;
    }

    /**
     * @param array<string, mixed> $data
     * @param array<string, callable> $rules
     */
    public function validateAll(array $data, array $rules): bool
    {
        $valid = true;

        foreach ($rules as $field => $rule) {
            $value = $data[$field] ?? null;

            if (!$rule($value)) {
                $valid = false;
            }
        }

        return $valid;
    }
}
