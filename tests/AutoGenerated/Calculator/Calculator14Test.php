<?php

declare(strict_types=1);

namespace Infection\BenchmarkSource\Test\AutoGenerated\Calculator;

use DivisionByZeroError;
use Infection\BenchmarkSource\AutoGenerated\Calculator\Calculator14;
use InvalidArgumentException;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\TestCase;

#[CoversClass(Calculator14::class)]
final class Calculator14Test extends TestCase
{
    private Calculator14 $calculator;

    protected function setUp(): void
    {
        $this->calculator = new Calculator14();
    }

    #[DataProvider('additionProvider')]
    public function test_adds_numbers(float $a, float $b, float $expected): void
    {
        $result = $this->calculator->add($a, $b);

        self::assertSame($expected, $result);
    }

    public static function additionProvider(): iterable
    {
        yield [1.0, 2.0, 3.0];
        yield [0.0, 0.0, 0.0];
        yield [-1.0, 1.0, 0.0];
        yield [5.5, 2.3, 7.8];
        yield [-10.0, -5.0, -15.0];
    }

    #[DataProvider('subtractionProvider')]
    public function test_subtracts_numbers(float $a, float $b, float $expected): void
    {
        $result = $this->calculator->subtract($a, $b);

        self::assertSame($expected, $result);
    }

    public static function subtractionProvider(): iterable
    {
        yield [5.0, 3.0, 2.0];
        yield [0.0, 0.0, 0.0];
        yield [-1.0, 1.0, -2.0];
        yield [10.5, 2.3, 8.2];
    }

    #[DataProvider('multiplicationProvider')]
    public function test_multiplies_numbers(float $a, float $b, float $expected): void
    {
        $result = $this->calculator->multiply($a, $b);

        self::assertSame($expected, $result);
    }

    public static function multiplicationProvider(): iterable
    {
        yield [2.0, 3.0, 6.0];
        yield [0.0, 5.0, 0.0];
        yield [-2.0, 3.0, -6.0];
        yield [2.5, 4.0, 10.0];
    }

    #[DataProvider('divisionProvider')]
    public function test_divides_numbers(float $a, float $b, float $expected): void
    {
        $result = $this->calculator->divide($a, $b);

        self::assertSame($expected, $result);
    }

    public static function divisionProvider(): iterable
    {
        yield [6.0, 2.0, 3.0];
        yield [10.0, 5.0, 2.0];
        yield [-10.0, 2.0, -5.0];
        yield [7.5, 2.5, 3.0];
    }

    public function test_division_by_zero_throws_exception(): void
    {
        $this->expectException(DivisionByZeroError::class);

        $this->calculator->divide(10.0, 0.0);
    }

    #[DataProvider('moduloProvider')]
    public function test_calculates_modulo(int $a, int $b, int $expected): void
    {
        $result = $this->calculator->modulo($a, $b);

        self::assertSame($expected, $result);
    }

    public static function moduloProvider(): iterable
    {
        yield [10, 3, 1];
        yield [20, 5, 0];
        yield [7, 4, 3];
        yield [15, 7, 1];
    }

    public function test_modulo_by_zero_throws_exception(): void
    {
        $this->expectException(DivisionByZeroError::class);

        $this->calculator->modulo(10, 0);
    }

    #[DataProvider('powerProvider')]
    public function test_calculates_power(float $base, float $exponent, float $expected): void
    {
        $result = $this->calculator->power($base, $exponent);

        self::assertSame($expected, $result);
    }

    public static function powerProvider(): iterable
    {
        yield [2.0, 3.0, 8.0];
        yield [5.0, 2.0, 25.0];
        yield [10.0, 0.0, 1.0];
        yield [2.0, -1.0, 0.5];
        yield [4.0, 0.5, 2.0];
    }

    #[DataProvider('squareRootProvider')]
    public function test_calculates_square_root(float $number, float $expected): void
    {
        $result = $this->calculator->squareRoot($number);

        self::assertSame($expected, $result);
    }

    public static function squareRootProvider(): iterable
    {
        yield [4.0, 2.0];
        yield [9.0, 3.0];
        yield [16.0, 4.0];
        yield [0.0, 0.0];
        yield [1.0, 1.0];
    }

    public function test_square_root_of_negative_throws_exception(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $this->calculator->squareRoot(-1.0);
    }

    #[DataProvider('absoluteProvider')]
    public function test_calculates_absolute_value(float $number, float $expected): void
    {
        $result = $this->calculator->absolute($number);

        self::assertSame($expected, $result);
    }

    public static function absoluteProvider(): iterable
    {
        yield [5.0, 5.0];
        yield [-5.0, 5.0];
        yield [0.0, 0.0];
        yield [-3.7, 3.7];
    }

    #[DataProvider('negateProvider')]
    public function test_negates_number(float $number, float $expected): void
    {
        $result = $this->calculator->negate($number);

        self::assertSame($expected, $result);
    }

    public static function negateProvider(): iterable
    {
        yield [5.0, -5.0];
        yield [-5.0, 5.0];
        yield [0.0, -0.0];
    }

    #[DataProvider('roundProvider')]
    public function test_rounds_number(float $number, int $precision, float $expected): void
    {
        $result = $this->calculator->round($number, $precision);

        self::assertSame($expected, $result);
    }

    public static function roundProvider(): iterable
    {
        yield [3.14159, 2, 3.14];
        yield [2.5, 0, 3.0];
        yield [1.678, 1, 1.7];
        yield [5.0, 0, 5.0];
    }

    public function test_round_rejects_negative_precision(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $this->calculator->round(3.14, -1);
    }

    #[DataProvider('percentageProvider')]
    public function test_calculates_percentage(float $value, float $percentage, float $expected): void
    {
        $result = $this->calculator->percentage($value, $percentage);

        self::assertSame($expected, $result);
    }

    public static function percentageProvider(): iterable
    {
        yield [100.0, 50.0, 50.0];
        yield [200.0, 25.0, 50.0];
        yield [80.0, 10.0, 8.0];
    }

    #[DataProvider('percentageOfProvider')]
    public function test_calculates_percentage_of(float $part, float $whole, float $expected): void
    {
        $result = $this->calculator->percentageOf($part, $whole);

        self::assertSame($expected, $result);
    }

    public static function percentageOfProvider(): iterable
    {
        yield [50.0, 100.0, 50.0];
        yield [25.0, 100.0, 25.0];
        yield [3.0, 12.0, 25.0];
    }

    public function test_percentage_of_zero_throws_exception(): void
    {
        $this->expectException(DivisionByZeroError::class);

        $this->calculator->percentageOf(50.0, 0.0);
    }

    #[DataProvider('factorialProvider')]
    public function test_calculates_factorial(int $n, float $expected): void
    {
        $result = $this->calculator->factorial($n);

        self::assertSame($expected, $result);
    }

    public static function factorialProvider(): iterable
    {
        yield [0, 1.0];
        yield [1, 1.0];
        yield [5, 120.0];
        yield [10, 3628800.0];
    }

    public function test_factorial_of_negative_throws_exception(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $this->calculator->factorial(-1);
    }

    #[DataProvider('fibonacciProvider')]
    public function test_calculates_fibonacci(int $n, int $expected): void
    {
        $result = $this->calculator->fibonacci($n);

        self::assertSame($expected, $result);
    }

    public static function fibonacciProvider(): iterable
    {
        yield [0, 0];
        yield [1, 1];
        yield [2, 1];
        yield [5, 5];
        yield [10, 55];
        yield [15, 610];
    }

    public function test_fibonacci_of_negative_throws_exception(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $this->calculator->fibonacci(-1);
    }

    #[DataProvider('gcdProvider')]
    public function test_calculates_gcd(int $a, int $b, int $expected): void
    {
        $result = $this->calculator->gcd($a, $b);

        self::assertSame($expected, $result);
    }

    public static function gcdProvider(): iterable
    {
        yield [12, 8, 4];
        yield [15, 25, 5];
        yield [7, 13, 1];
        yield [100, 50, 50];
        yield [-12, 8, 4];
    }

    #[DataProvider('lcmProvider')]
    public function test_calculates_lcm(int $a, int $b, int $expected): void
    {
        $result = $this->calculator->lcm($a, $b);

        self::assertSame($expected, $result);
    }

    public static function lcmProvider(): iterable
    {
        yield [4, 6, 12];
        yield [15, 25, 75];
        yield [7, 13, 91];
        yield [0, 0, 0];
    }

    #[DataProvider('isPrimeProvider')]
    public function test_checks_if_prime(int $number, bool $expected): void
    {
        $result = $this->calculator->isPrime($number);

        self::assertSame($expected, $result);
    }

    public static function isPrimeProvider(): iterable
    {
        yield [2, true];
        yield [3, true];
        yield [4, false];
        yield [17, true];
        yield [20, false];
        yield [1, false];
        yield [0, false];
        yield [-5, false];
    }

    #[DataProvider('isEvenProvider')]
    public function test_checks_if_even(int $number, bool $expected): void
    {
        $result = $this->calculator->isEven($number);

        self::assertSame($expected, $result);
    }

    public static function isEvenProvider(): iterable
    {
        yield [2, true];
        yield [3, false];
        yield [0, true];
        yield [-4, true];
        yield [-3, false];
    }

    #[DataProvider('isOddProvider')]
    public function test_checks_if_odd(int $number, bool $expected): void
    {
        $result = $this->calculator->isOdd($number);

        self::assertSame($expected, $result);
    }

    public static function isOddProvider(): iterable
    {
        yield [2, false];
        yield [3, true];
        yield [0, false];
        yield [-4, false];
        yield [-3, true];
    }

    #[DataProvider('sumProvider')]
    public function test_calculates_sum(array $numbers, float $expected): void
    {
        $result = $this->calculator->sum($numbers);

        self::assertSame($expected, $result);
    }

    public static function sumProvider(): iterable
    {
        yield [[1.0, 2.0, 3.0], 6.0];
        yield [[5.0, 10.0, 15.0], 30.0];
        yield [[], 0.0];
        yield [[1.5, 2.5], 4.0];
    }

    #[DataProvider('productProvider')]
    public function test_calculates_product(array $numbers, float $expected): void
    {
        $result = $this->calculator->product($numbers);

        self::assertSame($expected, $result);
    }

    public static function productProvider(): iterable
    {
        yield [[2.0, 3.0, 4.0], 24.0];
        yield [[5.0, 2.0], 10.0];
        yield [[], 0.0];
        yield [[1.0, 1.0, 1.0], 1.0];
    }

    #[DataProvider('averageProvider')]
    public function test_calculates_average(array $numbers, float $expected): void
    {
        $result = $this->calculator->average($numbers);

        self::assertSame($expected, $result);
    }

    public static function averageProvider(): iterable
    {
        yield [[1.0, 2.0, 3.0], 2.0];
        yield [[5.0, 10.0, 15.0], 10.0];
        yield [[2.0, 4.0], 3.0];
    }

    public function test_average_of_empty_array_throws_exception(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $this->calculator->average([]);
    }

    #[DataProvider('medianProvider')]
    public function test_calculates_median(array $numbers, float $expected): void
    {
        $result = $this->calculator->median($numbers);

        self::assertSame($expected, $result);
    }

    public static function medianProvider(): iterable
    {
        yield [[1.0, 2.0, 3.0], 2.0];
        yield [[1.0, 2.0, 3.0, 4.0], 2.5];
        yield [[5.0], 5.0];
        yield [[3.0, 1.0, 2.0], 2.0];
    }

    public function test_median_of_empty_array_throws_exception(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $this->calculator->median([]);
    }

    #[DataProvider('minProvider')]
    public function test_finds_minimum(array $numbers, float $expected): void
    {
        $result = $this->calculator->min($numbers);

        self::assertSame($expected, $result);
    }

    public static function minProvider(): iterable
    {
        yield [[1.0, 2.0, 3.0], 1.0];
        yield [[5.0, 10.0, 3.0], 3.0];
        yield [[-5.0, -10.0], -10.0];
    }

    public function test_min_of_empty_array_throws_exception(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $this->calculator->min([]);
    }

    #[DataProvider('maxProvider')]
    public function test_finds_maximum(array $numbers, float $expected): void
    {
        $result = $this->calculator->max($numbers);

        self::assertSame($expected, $result);
    }

    public static function maxProvider(): iterable
    {
        yield [[1.0, 2.0, 3.0], 3.0];
        yield [[5.0, 10.0, 3.0], 10.0];
        yield [[-5.0, -10.0], -5.0];
    }

    public function test_max_of_empty_array_throws_exception(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $this->calculator->max([]);
    }

    #[DataProvider('rangeProvider')]
    public function test_calculates_range(array $numbers, float $expected): void
    {
        $result = $this->calculator->range($numbers);

        self::assertSame($expected, $result);
    }

    public static function rangeProvider(): iterable
    {
        yield [[1.0, 2.0, 3.0], 2.0];
        yield [[5.0, 10.0, 3.0], 7.0];
        yield [[1.0], 0.0];
    }

    #[DataProvider('varianceProvider')]
    public function test_calculates_variance(array $numbers, float $expected): void
    {
        $result = $this->calculator->variance($numbers);

        self::assertSame($expected, $result);
    }

    public static function varianceProvider(): iterable
    {
        yield [[1.0, 2.0, 3.0], 0.6666666666666666];
        yield [[5.0, 5.0, 5.0], 0.0];
    }

    #[DataProvider('standardDeviationProvider')]
    public function test_calculates_standard_deviation(array $numbers, float $expected): void
    {
        $result = $this->calculator->standardDeviation($numbers);

        self::assertEqualsWithDelta($expected, $result, 0.0001);
    }

    public static function standardDeviationProvider(): iterable
    {
        yield [[1.0, 2.0, 3.0], 0.8165];
        yield [[5.0, 5.0, 5.0], 0.0];
    }

    #[DataProvider('clampProvider')]
    public function test_clamps_value(float $value, float $min, float $max, float $expected): void
    {
        $result = $this->calculator->clamp($value, $min, $max);

        self::assertSame($expected, $result);
    }

    public static function clampProvider(): iterable
    {
        yield [5.0, 0.0, 10.0, 5.0];
        yield [-5.0, 0.0, 10.0, 0.0];
        yield [15.0, 0.0, 10.0, 10.0];
        yield [7.5, 5.0, 8.0, 7.5];
    }

    public function test_clamp_rejects_invalid_range(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $this->calculator->clamp(5.0, 10.0, 5.0);
    }

    #[DataProvider('lerpProvider')]
    public function test_interpolates_linearly(float $start, float $end, float $t, float $expected): void
    {
        $result = $this->calculator->lerp($start, $end, $t);

        self::assertSame($expected, $result);
    }

    public static function lerpProvider(): iterable
    {
        yield [0.0, 10.0, 0.0, 0.0];
        yield [0.0, 10.0, 1.0, 10.0];
        yield [0.0, 10.0, 0.5, 5.0];
        yield [5.0, 15.0, 0.25, 7.5];
    }

    public function test_lerp_rejects_invalid_factor(): void
    {
        $this->expectException(InvalidArgumentException::class);

        $this->calculator->lerp(0.0, 10.0, 1.5);
    }

    public function test_memory_operations(): void
    {
        $this->calculator->storeInMemory(42.0);
        self::assertSame(42.0, $this->calculator->recallFromMemory());

        $this->calculator->addToMemory(8.0);
        self::assertSame(50.0, $this->calculator->recallFromMemory());

        $this->calculator->subtractFromMemory(10.0);
        self::assertSame(40.0, $this->calculator->recallFromMemory());

        $this->calculator->clearMemory();
        self::assertSame(0.0, $this->calculator->recallFromMemory());
    }
}
