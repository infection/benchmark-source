<?php

declare(strict_types=1);

namespace Infection\BenchmarkSource\Test\AutoGenerated\StringProcessor;

use Infection\BenchmarkSource\AutoGenerated\StringProcessor\StringProcessor00;
use InvalidArgumentException;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\TestCase;

#[CoversClass(StringProcessor00::class)]
final class StringProcessor00Test extends TestCase
{
    public function test_can_be_instantiated(): void
    {
        $processor = new StringProcessor00('Hello World');

        self::assertSame('Hello World', $processor->getValue());
        self::assertTrue($processor->isCaseSensitive());
    }

    public function test_can_be_instantiated_case_insensitive(): void
    {
        $processor = new StringProcessor00('Hello World', false);

        self::assertSame('Hello World', $processor->getValue());
        self::assertFalse($processor->isCaseSensitive());
    }

    public function test_rejects_empty_string(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('String length must be at least 1 characters, got 0.');

        new StringProcessor00('');
    }

    public function test_rejects_too_long_string(): void
    {
        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessageMatches('/String length must not exceed 10000 characters/');

        new StringProcessor00(str_repeat('a', 10001));
    }

    #[DataProvider('upperCaseProvider')]
    public function test_converts_to_uppercase(string $input, string $expected): void
    {
        $processor = new StringProcessor00($input);

        self::assertSame($expected, $processor->toUpperCase());
    }

    public static function upperCaseProvider(): iterable
    {
        yield ['hello', 'HELLO'];
        yield ['Hello World', 'HELLO WORLD'];
        yield ['ALREADY UPPER', 'ALREADY UPPER'];
        yield ['MiXeD CaSe', 'MIXED CASE'];
        yield ['123 abc', '123 ABC'];
    }

    #[DataProvider('lowerCaseProvider')]
    public function test_converts_to_lowercase(string $input, string $expected): void
    {
        $processor = new StringProcessor00($input);

        self::assertSame($expected, $processor->toLowerCase());
    }

    public static function lowerCaseProvider(): iterable
    {
        yield ['HELLO', 'hello'];
        yield ['Hello World', 'hello world'];
        yield ['already lower', 'already lower'];
        yield ['MiXeD CaSe', 'mixed case'];
        yield ['123 ABC', '123 abc'];
    }

    #[DataProvider('capitalizeProvider')]
    public function test_capitalizes_first_letter(string $input, string $expected): void
    {
        $processor = new StringProcessor00($input);

        self::assertSame($expected, $processor->capitalize());
    }

    public static function capitalizeProvider(): iterable
    {
        yield ['hello', 'Hello'];
        yield ['HELLO', 'Hello'];
        yield ['hello world', 'Hello world'];
        yield ['123 abc', '123 abc'];
    }

    #[DataProvider('capitalizeWordsProvider')]
    public function test_capitalizes_all_words(string $input, string $expected): void
    {
        $processor = new StringProcessor00($input);

        self::assertSame($expected, $processor->capitalizeWords());
    }

    public static function capitalizeWordsProvider(): iterable
    {
        yield ['hello world', 'Hello World'];
        yield ['HELLO WORLD', 'Hello World'];
        yield ['the quick brown fox', 'The Quick Brown Fox'];
        yield ['a', 'A'];
    }

    #[DataProvider('reverseProvider')]
    public function test_reverses_string(string $input, string $expected): void
    {
        $processor = new StringProcessor00($input);

        self::assertSame($expected, $processor->reverse());
    }

    public static function reverseProvider(): iterable
    {
        yield ['hello', 'olleh'];
        yield ['abc', 'cba'];
        yield ['12345', '54321'];
        yield ['Hello World', 'dlroW olleH'];
    }

    #[DataProvider('lengthProvider')]
    public function test_calculates_length(string $input, int $expected): void
    {
        $processor = new StringProcessor00($input);

        self::assertSame($expected, $processor->length());
    }

    public static function lengthProvider(): iterable
    {
        yield ['a', 1];
        yield ['hello', 5];
        yield ['Hello World', 11];
        yield ['   ', 3];
    }

    #[DataProvider('truncateProvider')]
    public function test_truncates_string(string $input, int $maxLength, string $suffix, string $expected): void
    {
        $processor = new StringProcessor00($input);

        self::assertSame($expected, $processor->truncate($maxLength, $suffix));
    }

    public static function truncateProvider(): iterable
    {
        yield ['Hello World', 5, '...', 'Hello...'];
        yield ['Hello World', 11, '...', 'Hello World'];
        yield ['Hello World', 20, '...', 'Hello World'];
        yield ['Hello World', 5, '', 'Hello'];
        yield ['Hello World', 8, '!', 'Hello Wo!'];
        yield ['Short', 10, '...', 'Short'];
    }

    public function test_truncate_rejects_negative_length(): void
    {
        $processor = new StringProcessor00('Hello');

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Max length must be non-negative, got -1.');

        $processor->truncate(-1);
    }

    #[DataProvider('containsProvider')]
    public function test_checks_contains(string $haystack, string $needle, bool $caseSensitive, bool $expected): void
    {
        $processor = new StringProcessor00($haystack, $caseSensitive);

        self::assertSame($expected, $processor->contains($needle));
    }

    public static function containsProvider(): iterable
    {
        yield ['Hello World', 'World', true, true];
        yield ['Hello World', 'world', true, false];
        yield ['Hello World', 'world', false, true];
        yield ['Hello World', 'xyz', true, false];
        yield ['Hello World', '', true, true];
        yield ['Hello World', 'Hello', true, true];
    }

    #[DataProvider('startsWithProvider')]
    public function test_checks_starts_with(string $value, string $prefix, bool $caseSensitive, bool $expected): void
    {
        $processor = new StringProcessor00($value, $caseSensitive);

        self::assertSame($expected, $processor->startsWith($prefix));
    }

    public static function startsWithProvider(): iterable
    {
        yield ['Hello World', 'Hello', true, true];
        yield ['Hello World', 'hello', true, false];
        yield ['Hello World', 'hello', false, true];
        yield ['Hello World', 'World', true, false];
        yield ['Hello World', '', true, true];
        yield ['Hello', 'Hello World', true, false];
    }

    #[DataProvider('endsWithProvider')]
    public function test_checks_ends_with(string $value, string $suffix, bool $caseSensitive, bool $expected): void
    {
        $processor = new StringProcessor00($value, $caseSensitive);

        self::assertSame($expected, $processor->endsWith($suffix));
    }

    public static function endsWithProvider(): iterable
    {
        yield ['Hello World', 'World', true, true];
        yield ['Hello World', 'world', true, false];
        yield ['Hello World', 'world', false, true];
        yield ['Hello World', 'Hello', true, false];
        yield ['Hello World', '', true, true];
        yield ['World', 'Hello World', true, false];
    }

    #[DataProvider('replaceProvider')]
    public function test_replaces_substring(string $value, string $search, string $replacement, bool $caseSensitive, string $expected): void
    {
        $processor = new StringProcessor00($value, $caseSensitive);

        self::assertSame($expected, $processor->replace($search, $replacement));
    }

    public static function replaceProvider(): iterable
    {
        yield ['Hello World', 'World', 'Universe', true, 'Hello Universe'];
        yield ['Hello World', 'world', 'Universe', true, 'Hello World'];
        yield ['Hello World', 'world', 'Universe', false, 'Hello Universe'];
        yield ['foo bar foo', 'foo', 'baz', true, 'baz bar baz'];
        yield ['Hello', 'xyz', 'abc', true, 'Hello'];
    }

    #[DataProvider('repeatProvider')]
    public function test_repeats_string(string $value, int $times, string $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->repeat($times));
    }

    public static function repeatProvider(): iterable
    {
        yield ['a', 0, ''];
        yield ['a', 1, 'a'];
        yield ['a', 3, 'aaa'];
        yield ['ab', 3, 'ababab'];
        yield ['Hello', 2, 'HelloHello'];
    }

    public function test_repeat_rejects_negative_count(): void
    {
        $processor = new StringProcessor00('Hello');

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Repetition count must be non-negative, got -1.');

        $processor->repeat(-1);
    }

    #[DataProvider('padLeftProvider')]
    public function test_pads_left(string $value, int $length, string $padString, string $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->padLeft($length, $padString));
    }

    public static function padLeftProvider(): iterable
    {
        yield ['Hello', 10, ' ', '     Hello'];
        yield ['Hello', 5, ' ', 'Hello'];
        yield ['Hello', 3, ' ', 'Hello'];
        yield ['Hi', 5, '0', '000Hi'];
        yield ['X', 5, 'ab', 'ababX'];
    }

    #[DataProvider('padRightProvider')]
    public function test_pads_right(string $value, int $length, string $padString, string $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->padRight($length, $padString));
    }

    public static function padRightProvider(): iterable
    {
        yield ['Hello', 10, ' ', 'Hello     '];
        yield ['Hello', 5, ' ', 'Hello'];
        yield ['Hello', 3, ' ', 'Hello'];
        yield ['Hi', 5, '0', 'Hi000'];
        yield ['X', 5, 'ab', 'Xabab'];
    }

    public function test_pad_left_rejects_negative_length(): void
    {
        $processor = new StringProcessor00('Hello');

        $this->expectException(InvalidArgumentException::class);

        $processor->padLeft(-1);
    }

    public function test_pad_left_rejects_empty_pad_string(): void
    {
        $processor = new StringProcessor00('Hello');

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Pad string cannot be empty.');

        $processor->padLeft(10, '');
    }

    #[DataProvider('splitProvider')]
    public function test_splits_string(string $value, string $delimiter, array $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->split($delimiter));
    }

    public static function splitProvider(): iterable
    {
        yield ['a,b,c', ',', ['a', 'b', 'c']];
        yield ['Hello World', ' ', ['Hello', 'World']];
        yield ['one', ',', ['one']];
        yield ['a:b:c:d', ':', ['a', 'b', 'c', 'd']];
    }

    public function test_split_rejects_empty_delimiter(): void
    {
        $processor = new StringProcessor00('Hello');

        $this->expectException(InvalidArgumentException::class);
        $this->expectExceptionMessage('Delimiter cannot be empty.');

        $processor->split('');
    }

    #[DataProvider('wordsProvider')]
    public function test_extracts_words(string $value, array $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->words());
    }

    public static function wordsProvider(): iterable
    {
        yield ['Hello World', ['Hello', 'World']];
        yield ['one two three', ['one', 'two', 'three']];
        yield ['  spaced  out  ', ['spaced', 'out']];
        yield ['single', ['single']];
    }

    #[DataProvider('wordCountProvider')]
    public function test_counts_words(string $value, int $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->wordCount());
    }

    public static function wordCountProvider(): iterable
    {
        yield ['Hello World', 2];
        yield ['one two three four', 4];
        yield ['single', 1];
        yield ['  spaced  out  ', 2];
    }

    #[DataProvider('reverseWordsProvider')]
    public function test_reverses_words(string $value, string $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->reverseWords());
    }

    public static function reverseWordsProvider(): iterable
    {
        yield ['Hello World', 'World Hello'];
        yield ['one two three', 'three two one'];
        yield ['single', 'single'];
    }

    #[DataProvider('isNumericProvider')]
    public function test_checks_is_numeric(string $value, bool $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->isNumeric());
    }

    public static function isNumericProvider(): iterable
    {
        yield ['123', true];
        yield ['123.45', true];
        yield ['-123', true];
        yield ['-123.45', true];
        yield ['abc', false];
        yield ['12a', false];
    }

    #[DataProvider('isAlphaProvider')]
    public function test_checks_is_alpha(string $value, bool $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->isAlpha());
    }

    public static function isAlphaProvider(): iterable
    {
        yield ['abc', true];
        yield ['ABC', true];
        yield ['AbCdEf', true];
        yield ['abc123', false];
        yield ['abc def', false];
        yield ['123', false];
    }

    #[DataProvider('isAlphanumericProvider')]
    public function test_checks_is_alphanumeric(string $value, bool $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->isAlphanumeric());
    }

    public static function isAlphanumericProvider(): iterable
    {
        yield ['abc123', true];
        yield ['ABC123', true];
        yield ['abc', true];
        yield ['123', true];
        yield ['abc def', false];
        yield ['abc-123', false];
    }

    #[DataProvider('trimProvider')]
    public function test_trims_whitespace(string $value, string $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->trim());
    }

    public static function trimProvider(): iterable
    {
        yield ['  Hello  ', 'Hello'];
        yield ['Hello', 'Hello'];
        yield ['  Hello', 'Hello'];
        yield ['Hello  ', 'Hello'];
        yield ["\n\tHello\n\t", 'Hello'];
    }

    #[DataProvider('slugProvider')]
    public function test_converts_to_slug(string $value, string $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->toSlug());
    }

    public static function slugProvider(): iterable
    {
        yield ['Hello World', 'hello-world'];
        yield ['The Quick Brown Fox', 'the-quick-brown-fox'];
        yield ['Hello  World', 'hello-world'];
        yield ['Hello-World', 'hello-world'];
        yield ['Hello_World', 'hello-world'];
    }

    #[DataProvider('camelCaseProvider')]
    public function test_converts_to_camel_case(string $value, string $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->toCamelCase());
    }

    public static function camelCaseProvider(): iterable
    {
        yield ['Hello World', 'helloWorld'];
        yield ['the quick brown fox', 'theQuickBrownFox'];
        yield ['single', 'single'];
        yield ['HELLO WORLD', 'helloWorld'];
    }

    #[DataProvider('snakeCaseProvider')]
    public function test_converts_to_snake_case(string $value, string $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->toSnakeCase());
    }

    public static function snakeCaseProvider(): iterable
    {
        yield ['Hello World', 'hello_world'];
        yield ['the quick brown fox', 'the_quick_brown_fox'];
        yield ['HELLO WORLD', 'hello_world'];
        yield ['single', 'single'];
    }

    #[DataProvider('kebabCaseProvider')]
    public function test_converts_to_kebab_case(string $value, string $expected): void
    {
        $processor = new StringProcessor00($value);

        self::assertSame($expected, $processor->toKebabCase());
    }

    public static function kebabCaseProvider(): iterable
    {
        yield ['Hello World', 'hello-world'];
        yield ['the quick brown fox', 'the-quick-brown-fox'];
        yield ['HELLO WORLD', 'hello-world'];
        yield ['single', 'single'];
    }
}
